// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: group_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteGroup = `-- name: DeleteGroup :one
DELETE FROM groups
WHERE id = $1 RETURNING "id", "name", "created_at", "updated_at"
`

type DeleteGroupRow struct {
	ID        int32            `json:"id"`
	Name      string           `json:"name"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) DeleteGroup(ctx context.Context, id int32) (DeleteGroupRow, error) {
	row := q.db.QueryRow(ctx, deleteGroup, id)
	var i DeleteGroupRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllGroups = `-- name: GetAllGroups :many
SELECT "id", "name", "start_time", "end_time", "created_at", "updated_at" FROM groups
`

type GetAllGroupsRow struct {
	ID        int32            `json:"id"`
	Name      string           `json:"name"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetAllGroups(ctx context.Context) ([]GetAllGroupsRow, error) {
	rows, err := q.db.Query(ctx, getAllGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGroupsRow
	for rows.Next() {
		var i GetAllGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT "id", "name",  "start_time", "end_time", "created_at", "updated_at" FROM groups WHERE id = $1
`

type GetGroupByIdRow struct {
	ID        int32            `json:"id"`
	Name      string           `json:"name"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetGroupById(ctx context.Context, id int32) (GetGroupByIdRow, error) {
	row := q.db.QueryRow(ctx, getGroupById, id)
	var i GetGroupByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupWithUsersByID = `-- name: GetGroupWithUsersByID :one
SELECT
    g.id,
    g.name,
    g.start_time,
    g.end_time,
    g.created_at,
    g.updated_at,
    (SELECT ug_check.admin FROM user_groups ug_check WHERE ug_check.group_id = g.id AND ug_check.user_id = $1) AS admin, -- Admin status of the requesting user for THIS group
    COALESCE(
        (SELECT json_agg(jsonb_build_object('id', u.id, 'username', u.username, 'email', u.email, 'admin', ug.admin, 'invited_at', ug.created_at))::text
         FROM users u
         JOIN user_groups ug ON u.id = ug.user_id
         WHERE ug.group_id = g.id),
        '[]'::text
    ) AS group_users
FROM
    groups g
WHERE
    g.id = $2
`

type GetGroupWithUsersByIDParams struct {
	RequestingUserID pgtype.Int4 `json:"requesting_user_id"`
	GroupID          int32       `json:"group_id"`
}

type GetGroupWithUsersByIDRow struct {
	ID         int32            `json:"id"`
	Name       string           `json:"name"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	Admin      bool             `json:"admin"`
	GroupUsers interface{}      `json:"group_users"`
}

func (q *Queries) GetGroupWithUsersByID(ctx context.Context, arg GetGroupWithUsersByIDParams) (GetGroupWithUsersByIDRow, error) {
	row := q.db.QueryRow(ctx, getGroupWithUsersByID, arg.RequestingUserID, arg.GroupID)
	var i GetGroupWithUsersByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Admin,
		&i.GroupUsers,
	)
	return i, err
}

const getGroupsForUser = `-- name: GetGroupsForUser :many
SELECT groups.id, groups.name, groups.start_time, groups.end_time, groups.created_at, ug.admin, groups.updated_at,
json_agg(jsonb_build_object('id', u2.id, 'username', u2.username, 'email', u2.email, 'admin', ug2.admin, 'invited_at', ug2.created_at))::text AS group_users 
FROM groups
JOIN user_groups ug ON ug.group_id = groups.id
JOIN users u ON u.id = ug.user_id
JOIN user_groups ug2 ON ug2.group_id = groups.id
JOIN users u2 ON u2.id = ug2.user_id
WHERE u.id = $1
GROUP BY groups.id, ug.id, u.id
`

type GetGroupsForUserRow struct {
	ID         int32            `json:"id"`
	Name       string           `json:"name"`
	StartTime  pgtype.Timestamp `json:"start_time"`
	EndTime    pgtype.Timestamp `json:"end_time"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	Admin      bool             `json:"admin"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	GroupUsers string           `json:"group_users"`
}

func (q *Queries) GetGroupsForUser(ctx context.Context, id int32) ([]GetGroupsForUserRow, error) {
	rows, err := q.db.Query(ctx, getGroupsForUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsForUserRow
	for rows.Next() {
		var i GetGroupsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.Admin,
			&i.UpdatedAt,
			&i.GroupUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGroup = `-- name: InsertGroup :one
INSERT INTO groups ("name", "start_time", "end_time") VALUES ($1, $2, $3) RETURNING id, name, created_at, updated_at, start_time, end_time
`

type InsertGroupParams struct {
	Name      string           `json:"name"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) InsertGroup(ctx context.Context, arg InsertGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, insertGroup, arg.Name, arg.StartTime, arg.EndTime)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET
    "name" = coalesce($2, "name"),
    "start_time" = coalesce($3, "start_time"),
    "end_time" = coalesce($4, "end_time")
WHERE id = $1
RETURNING "id", "name", "start_time", "end_time" "created_at", "updated_at"
`

type UpdateGroupParams struct {
	ID        int32            `json:"id"`
	Name      pgtype.Text      `json:"name"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

type UpdateGroupRow struct {
	ID        int32            `json:"id"`
	Name      string           `json:"name"`
	StartTime pgtype.Timestamp `json:"start_time"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (UpdateGroupRow, error) {
	row := q.db.QueryRow(ctx, updateGroup,
		arg.ID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
	)
	var i UpdateGroupRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
