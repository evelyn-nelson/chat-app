// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: group_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteGroup = `-- name: DeleteGroup :one
DELETE FROM groups
WHERE id = $1 RETURNING "id", "name", "created_at", "updated_at"
`

type DeleteGroupRow struct {
	ID        uuid.UUID        `json:"id"`
	Name      string           `json:"name"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) DeleteGroup(ctx context.Context, id uuid.UUID) (DeleteGroupRow, error) {
	row := q.db.QueryRow(ctx, deleteGroup, id)
	var i DeleteGroupRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllGroups = `-- name: GetAllGroups :many
SELECT "id", "name", "description", "location", "image_url", "blurhash", "start_time", "end_time", "created_at", "updated_at" FROM groups
`

type GetAllGroupsRow struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetAllGroups(ctx context.Context) ([]GetAllGroupsRow, error) {
	rows, err := q.db.Query(ctx, getAllGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGroupsRow
	for rows.Next() {
		var i GetAllGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.ImageUrl,
			&i.Blurhash,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupById = `-- name: GetGroupById :one
SELECT "id", "name", "description", "location", "image_url", "blurhash", "start_time", "end_time", "created_at", "updated_at" FROM groups WHERE id = $1
`

type GetGroupByIdRow struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetGroupById(ctx context.Context, id uuid.UUID) (GetGroupByIdRow, error) {
	row := q.db.QueryRow(ctx, getGroupById, id)
	var i GetGroupByIdRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.ImageUrl,
		&i.Blurhash,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupWithUsersByID = `-- name: GetGroupWithUsersByID :one
SELECT
    g.id,
    g.name,
    g."description",
    g.location,
    g.image_url,
    g.blurhash,
    g.start_time,
    g.end_time,
    g.created_at,
    g.updated_at,
    (SELECT ug_check.admin FROM user_groups ug_check WHERE ug_check.group_id = g.id AND ug_check.user_id = $1) AS admin, -- Admin status of the requesting user for THIS group
    COALESCE(
        (SELECT json_agg(jsonb_build_object('id', u.id, 'username', u.username, 'email', u.email, 'admin', ug.admin, 'invited_at', ug.created_at))::text
         FROM users u
         JOIN user_groups ug ON u.id = ug.user_id
         WHERE ug.group_id = g.id),
        '[]'::text
    ) AS group_users
FROM
    groups g
WHERE
    g.id = $2
`

type GetGroupWithUsersByIDParams struct {
	RequestingUserID *uuid.UUID `json:"requesting_user_id"`
	GroupID          uuid.UUID  `json:"group_id"`
}

type GetGroupWithUsersByIDRow struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	Admin       bool             `json:"admin"`
	GroupUsers  interface{}      `json:"group_users"`
}

func (q *Queries) GetGroupWithUsersByID(ctx context.Context, arg GetGroupWithUsersByIDParams) (GetGroupWithUsersByIDRow, error) {
	row := q.db.QueryRow(ctx, getGroupWithUsersByID, arg.RequestingUserID, arg.GroupID)
	var i GetGroupWithUsersByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.ImageUrl,
		&i.Blurhash,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Admin,
		&i.GroupUsers,
	)
	return i, err
}

const getGroupsForUser = `-- name: GetGroupsForUser :many
SELECT groups.id, groups.name, groups."description", groups."location", groups."image_url", groups."blurhash", groups.start_time, groups.end_time, groups.created_at, ug.admin, groups.updated_at,
json_agg(jsonb_build_object('id', u2.id, 'username', u2.username, 'email', u2.email, 'admin', ug2.admin, 'invited_at', ug2.created_at))::text AS group_users 
FROM groups
JOIN user_groups ug ON ug.group_id = groups.id
JOIN users u ON u.id = ug.user_id
JOIN user_groups ug2 ON ug2.group_id = groups.id
JOIN users u2 ON u2.id = ug2.user_id
WHERE u.id = $1
GROUP BY groups.id, ug.id, u.id
`

type GetGroupsForUserRow struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	Admin       bool             `json:"admin"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	GroupUsers  string           `json:"group_users"`
}

func (q *Queries) GetGroupsForUser(ctx context.Context, id uuid.UUID) ([]GetGroupsForUserRow, error) {
	rows, err := q.db.Query(ctx, getGroupsForUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsForUserRow
	for rows.Next() {
		var i GetGroupsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.ImageUrl,
			&i.Blurhash,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.Admin,
			&i.UpdatedAt,
			&i.GroupUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGroup = `-- name: InsertGroup :one
INSERT INTO groups ("id", "name", "start_time", "end_time", "description", "location", "image_url", "blurhash") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, name, created_at, updated_at, start_time, end_time, description, location, image_url, blurhash
`

type InsertGroupParams struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
}

func (q *Queries) InsertGroup(ctx context.Context, arg InsertGroupParams) (Group, error) {
	row := q.db.QueryRow(ctx, insertGroup,
		arg.ID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
		arg.Location,
		arg.ImageUrl,
		arg.Blurhash,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.Location,
		&i.ImageUrl,
		&i.Blurhash,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET
    "name" = coalesce($2, "name"),
    "start_time" = coalesce($3, "start_time"),
    "end_time" = coalesce($4, "end_time"),
    "description" = coalesce($5, "description"),
    "location" = coalesce($6, "location"),
    "image_url" = coalesce($7, "image_url"),
    "blurhash" = coalesce($8, "blurhash")
WHERE id = $1
RETURNING "id", "name", "start_time", "end_time", "description", "location", "image_url", "blurhash", "created_at", "updated_at"
`

type UpdateGroupParams struct {
	ID          uuid.UUID        `json:"id"`
	Name        pgtype.Text      `json:"name"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
}

type UpdateGroupRow struct {
	ID          uuid.UUID        `json:"id"`
	Name        string           `json:"name"`
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	ImageUrl    pgtype.Text      `json:"image_url"`
	Blurhash    pgtype.Text      `json:"blurhash"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (UpdateGroupRow, error) {
	row := q.db.QueryRow(ctx, updateGroup,
		arg.ID,
		arg.Name,
		arg.StartTime,
		arg.EndTime,
		arg.Description,
		arg.Location,
		arg.ImageUrl,
		arg.Blurhash,
	)
	var i UpdateGroupRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
		&i.Description,
		&i.Location,
		&i.ImageUrl,
		&i.Blurhash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
