// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: device_keys_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const deleteAllDeviceKeysForUser = `-- name: DeleteAllDeviceKeysForUser :exec
DELETE FROM device_keys
WHERE user_id = $1
`

func (q *Queries) DeleteAllDeviceKeysForUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllDeviceKeysForUser, userID)
	return err
}

const deleteDeviceKey = `-- name: DeleteDeviceKey :exec
DELETE FROM device_keys
WHERE user_id = $1 AND device_identifier = $2
`

type DeleteDeviceKeyParams struct {
	UserID           uuid.UUID `json:"user_id"`
	DeviceIdentifier string    `json:"device_identifier"`
}

func (q *Queries) DeleteDeviceKey(ctx context.Context, arg DeleteDeviceKeyParams) error {
	_, err := q.db.Exec(ctx, deleteDeviceKey, arg.UserID, arg.DeviceIdentifier)
	return err
}

const getDeviceKeyByIdentifier = `-- name: GetDeviceKeyByIdentifier :one
SELECT id, user_id, device_identifier, public_key, created_at, last_seen_at FROM device_keys
WHERE user_id = $1 AND device_identifier = $2
LIMIT 1
`

type GetDeviceKeyByIdentifierParams struct {
	UserID           uuid.UUID `json:"user_id"`
	DeviceIdentifier string    `json:"device_identifier"`
}

func (q *Queries) GetDeviceKeyByIdentifier(ctx context.Context, arg GetDeviceKeyByIdentifierParams) (DeviceKey, error) {
	row := q.db.QueryRow(ctx, getDeviceKeyByIdentifier, arg.UserID, arg.DeviceIdentifier)
	var i DeviceKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceIdentifier,
		&i.PublicKey,
		&i.CreatedAt,
		&i.LastSeenAt,
	)
	return i, err
}

const getDeviceKeysForUser = `-- name: GetDeviceKeysForUser :many
SELECT id, user_id, device_identifier, public_key, created_at, last_seen_at FROM device_keys
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetDeviceKeysForUser(ctx context.Context, userID uuid.UUID) ([]DeviceKey, error) {
	rows, err := q.db.Query(ctx, getDeviceKeysForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeviceKey
	for rows.Next() {
		var i DeviceKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceIdentifier,
			&i.PublicKey,
			&i.CreatedAt,
			&i.LastSeenAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerDeviceKey = `-- name: RegisterDeviceKey :one
INSERT INTO device_keys (
    user_id,
    device_identifier,
    public_key,
    last_seen_at
) VALUES (
    $1, $2, $3, now()
)
ON CONFLICT (user_id, device_identifier) DO UPDATE SET
    public_key = EXCLUDED.public_key,
    last_seen_at = now()
RETURNING id, user_id, device_identifier, public_key, created_at, last_seen_at
`

type RegisterDeviceKeyParams struct {
	UserID           uuid.UUID `json:"user_id"`
	DeviceIdentifier string    `json:"device_identifier"`
	PublicKey        []byte    `json:"public_key"`
}

func (q *Queries) RegisterDeviceKey(ctx context.Context, arg RegisterDeviceKeyParams) (DeviceKey, error) {
	row := q.db.QueryRow(ctx, registerDeviceKey, arg.UserID, arg.DeviceIdentifier, arg.PublicKey)
	var i DeviceKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceIdentifier,
		&i.PublicKey,
		&i.CreatedAt,
		&i.LastSeenAt,
	)
	return i, err
}

const updateDeviceKeyLastSeen = `-- name: UpdateDeviceKeyLastSeen :exec
UPDATE device_keys
SET last_seen_at = now()
WHERE user_id = $1 AND device_identifier = $2
`

type UpdateDeviceKeyLastSeenParams struct {
	UserID           uuid.UUID `json:"user_id"`
	DeviceIdentifier string    `json:"device_identifier"`
}

func (q *Queries) UpdateDeviceKeyLastSeen(ctx context.Context, arg UpdateDeviceKeyLastSeenParams) error {
	_, err := q.db.Exec(ctx, updateDeviceKeyLastSeen, arg.UserID, arg.DeviceIdentifier)
	return err
}
