// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: message_queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteMessage = `-- name: DeleteMessage :one
DELETE FROM messages
WHERE id = $1
RETURNING id, user_id, group_id, created_at
`

type DeleteMessageRow struct {
	ID        uuid.UUID        `json:"id"`
	UserID    *uuid.UUID       `json:"user_id"`
	GroupID   *uuid.UUID       `json:"group_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// Deletes a message by its ID.
// Returns the deleted message's core fields (E2EE fields might be large to return).
func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) (DeleteMessageRow, error) {
	row := q.db.QueryRow(ctx, deleteMessage, id)
	var i DeleteMessageRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
	)
	return i, err
}

const getAllMessages = `-- name: GetAllMessages :many
SELECT
    id,
    user_id,
    group_id,
    created_at,
    updated_at,
    ciphertext,
    message_type,
    msg_nonce,
    key_envelopes
FROM messages
ORDER BY created_at DESC
`

type GetAllMessagesRow struct {
	ID           uuid.UUID        `json:"id"`
	UserID       *uuid.UUID       `json:"user_id"`
	GroupID      *uuid.UUID       `json:"group_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Ciphertext   []byte           `json:"ciphertext"`
	MessageType  MessageType      `json:"message_type"`
	MsgNonce     []byte           `json:"msg_nonce"`
	KeyEnvelopes []byte           `json:"key_envelopes"`
}

// Retrieves all messages. Use with caution on large datasets.
// Primarily for admin or debugging.
func (q *Queries) GetAllMessages(ctx context.Context) ([]GetAllMessagesRow, error) {
	rows, err := q.db.Query(ctx, getAllMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllMessagesRow
	for rows.Next() {
		var i GetAllMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Ciphertext,
			&i.MessageType,
			&i.MsgNonce,
			&i.KeyEnvelopes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageById = `-- name: GetMessageById :one
SELECT
    id,
    user_id,
    group_id,
    created_at,
    updated_at,
    ciphertext,
    message_type,
    msg_nonce,
    key_envelopes
FROM messages
WHERE id = $1
`

type GetMessageByIdRow struct {
	ID           uuid.UUID        `json:"id"`
	UserID       *uuid.UUID       `json:"user_id"`
	GroupID      *uuid.UUID       `json:"group_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Ciphertext   []byte           `json:"ciphertext"`
	MessageType  MessageType      `json:"message_type"`
	MsgNonce     []byte           `json:"msg_nonce"`
	KeyEnvelopes []byte           `json:"key_envelopes"`
}

func (q *Queries) GetMessageById(ctx context.Context, id uuid.UUID) (GetMessageByIdRow, error) {
	row := q.db.QueryRow(ctx, getMessageById, id)
	var i GetMessageByIdRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ciphertext,
		&i.MessageType,
		&i.MsgNonce,
		&i.KeyEnvelopes,
	)
	return i, err
}

const getMessagesForGroup = `-- name: GetMessagesForGroup :many
SELECT
    m.id,
    m.user_id,
    u.username,
    m.group_id,
    m.created_at,
    m.updated_at,
    m.ciphertext,
    m.message_type,
    m.msg_nonce,
    m.key_envelopes
FROM messages m
JOIN users u ON m.user_id = u.id
WHERE m.group_id = $1
`

type GetMessagesForGroupRow struct {
	ID           uuid.UUID        `json:"id"`
	UserID       *uuid.UUID       `json:"user_id"`
	Username     string           `json:"username"`
	GroupID      *uuid.UUID       `json:"group_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Ciphertext   []byte           `json:"ciphertext"`
	MessageType  MessageType      `json:"message_type"`
	MsgNonce     []byte           `json:"msg_nonce"`
	KeyEnvelopes []byte           `json:"key_envelopes"`
}

func (q *Queries) GetMessagesForGroup(ctx context.Context, groupID *uuid.UUID) ([]GetMessagesForGroupRow, error) {
	rows, err := q.db.Query(ctx, getMessagesForGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesForGroupRow
	for rows.Next() {
		var i GetMessagesForGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Ciphertext,
			&i.MessageType,
			&i.MsgNonce,
			&i.KeyEnvelopes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelevantMessages = `-- name: GetRelevantMessages :many
SELECT
    m.id,
    m.group_id,
    m.user_id AS sender_id,
    m.created_at AS "timestamp",
    m.ciphertext,
    m.message_type,
    m.msg_nonce,
    m.key_envelopes
FROM messages m
JOIN user_groups ug ON ug.group_id = m.group_id
JOIN users u_member ON ug.user_id = u_member.id 
JOIN users u_sender ON m.user_id = u_sender.id
JOIN groups g ON m.group_id = g.id
WHERE u_member.id = $1
AND m.created_at > ug.created_at
`

type GetRelevantMessagesRow struct {
	ID           uuid.UUID        `json:"id"`
	GroupID      *uuid.UUID       `json:"group_id"`
	SenderID     *uuid.UUID       `json:"sender_id"`
	Timestamp    pgtype.Timestamp `json:"timestamp"`
	Ciphertext   []byte           `json:"ciphertext"`
	MessageType  MessageType      `json:"message_type"`
	MsgNonce     []byte           `json:"msg_nonce"`
	KeyEnvelopes []byte           `json:"key_envelopes"`
}

func (q *Queries) GetRelevantMessages(ctx context.Context, id uuid.UUID) ([]GetRelevantMessagesRow, error) {
	rows, err := q.db.Query(ctx, getRelevantMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelevantMessagesRow
	for rows.Next() {
		var i GetRelevantMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.SenderID,
			&i.Timestamp,
			&i.Ciphertext,
			&i.MessageType,
			&i.MsgNonce,
			&i.KeyEnvelopes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO messages (
    id,
    user_id,
    group_id,
    ciphertext,
    message_type,
    msg_nonce,
    key_envelopes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, group_id, created_at, updated_at, ciphertext, message_type, msg_nonce, key_envelopes
`

type InsertMessageParams struct {
	ID           uuid.UUID   `json:"id"`
	UserID       *uuid.UUID  `json:"user_id"`
	GroupID      *uuid.UUID  `json:"group_id"`
	Ciphertext   []byte      `json:"ciphertext"`
	MessageType  MessageType `json:"message_type"`
	MsgNonce     []byte      `json:"msg_nonce"`
	KeyEnvelopes []byte      `json:"key_envelopes"`
}

type InsertMessageRow struct {
	ID           uuid.UUID        `json:"id"`
	UserID       *uuid.UUID       `json:"user_id"`
	GroupID      *uuid.UUID       `json:"group_id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Ciphertext   []byte           `json:"ciphertext"`
	MessageType  MessageType      `json:"message_type"`
	MsgNonce     []byte           `json:"msg_nonce"`
	KeyEnvelopes []byte           `json:"key_envelopes"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (InsertMessageRow, error) {
	row := q.db.QueryRow(ctx, insertMessage,
		arg.ID,
		arg.UserID,
		arg.GroupID,
		arg.Ciphertext,
		arg.MessageType,
		arg.MsgNonce,
		arg.KeyEnvelopes,
	)
	var i InsertMessageRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ciphertext,
		&i.MessageType,
		&i.MsgNonce,
		&i.KeyEnvelopes,
	)
	return i, err
}
